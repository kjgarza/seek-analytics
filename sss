
class BioTermsMining:
    def __init__(self):
        self.email = "garzaguk@cs.man.ac.uk"
        users_object = UsersDb()
        self.users = users_object.getRows()
        people_object = PeopleDb()
        self.people = people_object.getRows()
        relations_object = RelationsDb()
        self.relations = relations_object.getRows()
        publications_object = PublicationsDb()
        self.publications = publications_object.getRows()
        data_files_object = DataFilesDb()
        self.data_files = data_files_object.getRows()
        self.db = sqlsoup.SQLSoup('mysql+mysqldb://root:@127.0.0.1/sysmo?charset=ascii')
        self.data_view = DataTableView(self.db.data_files)
        self.model_view = ModelTableView(self.db.models)


    def get_descriptions(self, contributor_ids):
        # filtered  = self.data_view.view[self.data_view.view.contributor_id.isin(contributor_ids)]
        # self.data_view.get_terms_db(filtered["id"])
        # return self.data_view.view[self.data_view.view.contributor_id.isin(contributor_ids)]

        filtered = self.model_view.view[self.model_view.view.contributor_id.isin(contributor_ids)]
        self.model_view.get_terms_db(filtered["id"])
        return self.model_view.view[self.model_view.view.contributor_id.isin(contributor_ids)]


    # def get_descriptions(self, contributor_ids):
    #     try:
    #         data_files = self.data_files[self.data_files.contributor_id.isin(contributor_ids)]
    #         data_files = data_files[['id', 'contributor_id', 'title', 'description']]
    #         data_files['terms'] = ""
    #         data_files['terms'] = data_files.apply(
    #             lambda row: TermsBag().termine_service(row['title'] + ". " + row['description']), axis=1)
    #     except ValueError:
    #         pass
    #
    #     if 0 == data_files.shape[0]:
    #         print("No Results get_descriptions")
    #
    #     assert isinstance(data_files, pandas.DataFrame)
    #     return data_files
    #
    #
    #


    # def get_descriptions(self, contributor_ids):
    #
    #     db = sqlsoup.SQLSoup('mysql+mysqldb://root:@127.0.0.1/sysmo?charset=utf8')
    #
    #     # db.join(db.models, db.model_types, db.models.model_type_id==db.model_types.id, isouter=True)
    #
    #     # s = db.execute("SELECT * FROM models")
    #     s = db.execute("SELECT models.model_type_id, models.id, models.contributor_id, models.title, models.description, model_types.title  as type_title \
    #         FROM models \
    #         LEFT JOIN model_types \
    #         ON models.model_type_id=model_types.id;")
    #     models = pandas.DataFrame(s.fetchall())
    #     models.columns = s.keys()
    #     try:
    #         models = models[models.contributor_id.isin(contributor_ids)]
    #
    #         models = models[['id', 'contributor_id', 'title', 'description', 'type_title']]
    #         models['terms'] = ""
    #         models['terms'] = models.apply(
    #             lambda row: TermsBag().termine_service(row['title'] + " " + row['description']), axis=1)
    #     except ValueError:
    #         print("ValueError")
    #
    #     assert isinstance(models, pandas.DataFrame)
    #     return models


    def ask_publication_authors(self, pubmed_id):
        """

        :param pubme_ids:
        """
        pubmed_object = PubmedSearcher(self.email)
        names = pubmed_object.get_authors_list(pubmed_id)

        concatenated = pandas.DataFrame.merge(self.users, self.people, how='left', left_on='person_id', right_on='id',
                                              left_index=False, right_index=False, sort=True,
                                              suffixes=('_x', '_y'), copy=True)

        filtered = concatenated[concatenated.last_name.isin(names["LastName"])]
        r = filtered["contributor_id"]

        if 0 == filtered.shape[0]:
            print("No Results ask_publication_authors")

        assert isinstance(r, pandas.Series)
        return r


    def get_publication(self, pubmed_id):

        """

        :param pubmed_id:
        :return:
        """
        # publication = pandas.DataFrame.from_csv('/Users/kristian/Desktop/' + pubmed_id, sep='\t')


        handle = efetch(db='pubmed', id=pubmed_id, retmode='text', rettype='abstract', email='garzaguk@.cs.man.ac.uk')
        text = handle.read()

        terms = TermsBag()
        terms.termine_service(text)
        publication = terms.to_data_frame()

        #
        # text = open('/Users/kristian/Desktop/' + pubmed_id + "m")
        #
        # terms = TermsBag()
        # terms.termine_service(text.read())
        # publication = terms.to_data_frame()


        assert isinstance(publication, pandas.DataFrame)
        return publication

    def compare_data(self, descriptions, publication):

        descriptions['no_similar_terms'] = 0
        compared2 = 0

        def windchill(terms):
            df_terms = TermsBag(text=terms)
            df_terms = df_terms.to_data_frame()
            compared = df_terms[df_terms.terms.isin(publication["terms"])]
            return compared.shape[0]


        def find_term_app(descriptions):
            return descriptions[descriptions["no_similar_terms"] != 0]

        def max_term_app(descriptions):
            return descriptions[descriptions["no_similar_terms"] == descriptions["no_similar_terms"].max()]

        def max_half_term_app(descriptions):
            """
                Get the assets with the more number of similar terms to the paper and a bit more
            :param descriptions:
            :return:
            """
            return descriptions[descriptions["no_similar_terms"] >= (descriptions["no_similar_terms"].max() / 2)]

        # publication_bag = TermsBag()
        # publication_bag.terms = publication["terms"]
        #
        # descriptions['no_similar_terms'] = descriptions.apply(lambda row: TermsBag(row['terms']).compare_with(publication_bag).shape[0], axis=1)
        # compared2 = max_half_term_app(descriptions)
        #
        #


        try:
            descriptions['no_similar_terms'] = descriptions.apply(lambda row: windchill(row['terms']), axis=1)
            compared2 = max_half_term_app(descriptions)
        except ValueError:
            print("lalala")

        # if 0 == compared2.shape[0]:
        #     print("No Results compare_data")

        return compared2


    def get_data_sharing_ratio(self, pubmed_id):
        """

        :type pubmed_id: basestring
        """
        used_items = self.get_used_items(pubmed_id)
        contributors_ids = self.ask_publication_authors(pubmed_id)
        # contributors_ids   = filter_data(descriptions, authors)
        descriptions = self.get_descriptions(contributors_ids)
        publications = self.get_publication(pubmed_id)
        shared_items = self.compare_data(descriptions, publications)
        print("DS Ratio:", (shared_items / used_items))

        # def get_used_items(self,pubmed_id):
        # authors = self.ask_publication_authors(self, pubmed_id)
        # authors


    def get_recall(self, pubmed_id, asset_ids):
        r = 0

        publication = self.publications[self.publications.pubmed_id.isin([int(pubmed_id)])]
        pubmed_id_relations = self.relations[self.relations.object_id.isin(publication["id"])]
        pubmed_id_relations = pubmed_id_relations[pubmed_id_relations["subject_type"] == "Model"]
        # pubmed_id_relations = pubmed_id_relations[pubmed_id_relations["subject_type"] == "DataFile"]

        matched = pubmed_id_relations[pubmed_id_relations.subject_id.isin(asset_ids)]
        not_matched = pubmed_id_relations[~pubmed_id_relations.subject_id.isin(asset_ids)]
        predicted = asset_ids.shape[0]
        ground_truth = pubmed_id_relations.shape[0]

        # s = self.db.execute("SELECT * FROM data_files")
        # df = pandas.DataFrame(s.fetchall())
        # df.columns = s.keys()
        # print(not_matched)
        # print df[df.id.isin(not_matched["subject_id"])]


        true_positives = matched.shape[0]

        false_positives = abs(predicted - true_positives)

        false_negatives = abs(not_matched.shape[0])

        print(true_positives, false_negatives, asset_ids.shape[0], ground_truth)

        try:
            precision = true_positives / (true_positives + false_positives)
            recall = true_positives / (true_positives + false_negatives)
            r = [{'pubmed_id': pubmed_id, 'recall': recall, 'precision': precision}]
        except ZeroDivisionError:
            print "Oops!  ZeroDivisionError  Try again..."
        else:
            print("Recall: ", recall)
            print("Precision: ", precision)

        return r

    def get_recall_pubmed_id(self, pubmed_id):
        r = 0
        try:
            contributors_ids = self.ask_publication_authors(pubmed_id)

            # contributors_ids   = filter_data(descriptions, authors)
            # import random
            #
            # la=contributors_ids.tolist()
            # la.extend(random.sample(range(22, 300, 1),10))
            # print(la)
            #
            # contributors_ids =pandas.Series(la)
            # print(contributors_ids)
            descriptions = self.get_descriptions(contributors_ids)
            publications = self.get_publication(pubmed_id)
            compared = self.compare_data(descriptions, publications)

            r = self.get_recall(pubmed_id, compared["id"])
        except TypeError:
            print("TypeError")
        return r

